package Algorithm.Bitoperation.p521;

/**
 * \* Created with IntelliJ IDEA.
 * \* User: LinZiYu
 * \* Date: 2020/5/21
 * \* Time: 22:04
 * \* Description:
 *
 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
 *
 * 示例 1：
 *
 * 输入：00000000000000000000000000001011
 *
 * 输出：3
 *
 * 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 *
 *
 *
 * 示例 2：
 *
 * 输入：00000000000000000000000010000000
 *
 * 输出：1
 *
 * 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 *
 *
 *
 * 示例 3：
 *
 * 输入：11111111111111111111111111111101
 *
 * 输出：31
 *
 * 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 *
 *
 *
 * 提示：
 *
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 *
 *
 *
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
 * \
 */
public class T2 {

    //首先最容易想到的方法是：我们直接把目标数转化成二进制数，然后遍历每一位看看是不是1，如果是1就记录下来。通过这种比较暴力的方式，来进行求解。比如Java中，int类型是32位，我们只要能计算出当前是第几位，就可以顺利进行求解。

    public int hammingWeight(int n) {
                int result = 0;
               //初始化掩码为1
                int mask = 1;
                for (int i = 0; i < 32; i++) {
                       if ((n & mask) != 0) {
                               result++;
                           }
                        mask = mask << 1;
                }
                return result;
    }


    //&按位与的运算规则是将两边的数转换为二进制位，
    // 然后运算最终值，运算规则即(两个为真才为真)1&1=1 , 1&0=0 , 0&1=0 , 0&0=0

//3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ，
// 那么就是011 & 101，由按位与运算规则得知，001 & 101等于0000 0001，最终值为1
    //7的二进制位是0000 0111，那就是111 & 101等于101，也就是0000 0101，故值为5


    public static void test_1() {
        int i = 3 & 5;

        int j = 5 & 7;

        System.out.println(i);
        System.out.println(j);
    }


    //位运算小技巧: 对于任意一个数，将 n 和 n-1 进行 & 运算，我们都可以把 n 中最低位的 1 变成 0


    public int hammingWeight_Better(int n) {

        int c = 0;

        while (n > 0) {
            n &= (n - 1);
            ++c;
        }

        return c;
    }


    public static void main(String[] args) {

//        System.out.println(new T2().hammingWeight(8));

//        test_1();
        //1
        //5

        System.out.println(new T2().hammingWeight(121));
        System.out.println(new T2().hammingWeight_Better(121));
    }

}
